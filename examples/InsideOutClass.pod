
use strict;
use warnings;

package # hide the package from PAUSE
    InsideOutClass::Attribute;

use base 'Class::MOP::Attribute';

sub initialize_instance_slot {
    my ($self, $meta_instance, $instance, $params) = @_;
    my $init_arg = $self->init_arg;
    # try to fetch the init arg from the %params ...

    my $class_meta_instance = $self->associated_class->get_meta_instance;

    if ( exists $params->{$init_arg} ) {
        $meta_instance->set_slot_value($instance, $self->name, $params->{$init_arg});
    } elsif ( $self->default ) {
        $meta_instance->set_slot_value($instance, $self->name, $self->default($instance));
    }
}

sub method_metaclass {
    # this should really be overriding the default values of the attribute
    return {
        accessor  => 'InsideOutClass::Method::Accessor',
        reader    => 'InsideOutClass::Method::Reader',
        writer    => 'InsideOutClass::Method::Writer',
        predicate => 'InsideOutClass::Method::Predicate',
    }
}

package # hide the package from PAUSE
    InsideOutClass::Method::Accessor;

use base 'Class::MOP::Method::Accessor';

## Method generation helpers

sub is_inline { 0 }

sub _generate_method {
    my $attr       = (shift)->associated_attribute;
    my $meta_class = $attr->associated_class;
    my $attr_name  = $attr->name;
    return sub {
        my $meta_instance = $meta_class->get_meta_instance;
        $meta_instance->set_slot_value($_[0], $attr_name, $_[1]) if scalar(@_) == 2;
        $meta_instance->get_slot_value($_[0], $attr_name);
    };
}

package # hide the package from PAUSE
    InsideOutClass::Method::Reader;

use Carp 'confess';

use base 'Class::MOP::Method::Reader';

sub is_inline { 0 }

sub _generate_method {
    my $attr       = (shift)->associated_attribute;
    my $meta_class = $attr->associated_class;
    my $attr_name  = $attr->name;
    return sub {
        confess "Cannot assign a value to a read-only accessor" if @_ > 1;
        $meta_class->get_meta_instance
                   ->get_slot_value($_[0], $attr_name);
    };
}

package # hide the package from PAUSE
    InsideOutClass::Method::Writer;

use base 'Class::MOP::Method::Writer';

sub is_inline { 0 }

sub _generate_method {
    my $attr       = (shift)->associated_attribute;
    my $meta_class = $attr->associated_class;
    my $attr_name  = $attr->name;
    return sub {
        $meta_class->get_meta_instance
                   ->set_slot_value($_[0], $attr_name, $_[1]);
    };
}

package # hide the package from PAUSE
    InsideOutClass::Method::Predicate;

use base 'Class::MOP::Method::Predicate';

sub is_inline { 0 }

sub _generate_method {
    my $attr       = (shift)->associated_attribute;
    my $meta_class = $attr->associated_class;
    my $attr_name  = $attr->name;
    return sub {
        $meta_class->get_meta_instance
                    ->is_slot_initialized($_[0], $attr_name);
    };
}

package # hide the package from PAUSE
    InsideOutClass::Instance;

use Scalar::Util 'refaddr';

use base 'Class::MOP::Instance';

sub new {
    my ( $class, @args ) = @_;

    my $self = $class->SUPER::new(@args);

    foreach my $slot_name ( $self->get_all_slots ) {
        $self->associated_metaclass->add_package_symbol(('%' . $slot_name) => {})
            unless $self->associated_metaclass->has_package_symbol('%' . $slot_name);
    }

    return $self;
}

sub create_instance {
	my ($self, $class) = @_;

    bless \(my $instance), $self->_class_name;
}

sub get_slot_value {
	my ($self, $instance, $slot_name) = @_;
	$self->associated_metaclass->get_package_symbol('%' . $slot_name)->{refaddr $instance};
}

sub set_slot_value {
	my ($self, $instance, $slot_name, $value) = @_;
	$self->associated_metaclass->get_package_symbol('%' . $slot_name)->{refaddr $instance} = $value;
}

sub initialize_slot {
    my ($self, $instance, $slot_name) = @_;
    $self->associated_metaclass->get_package_symbol('%' . $slot_name)->{refaddr $instance} = undef;
}

sub is_slot_initialized {
	my ($self, $instance, $slot_name) = @_;
	exists $self->associated_metaclass->get_package_symbol('%' . $slot_name)->{refaddr $instance};
}

1;

__END__

=pod

=head1 NAME

InsideOutClass - A set of example metaclasses which implement the Inside-Out technique

=head1 SYNOPSIS

  package Foo;

  use metaclass (
    ':attribute_metaclass' => 'InsideOutClass::Attribute',
    ':instance_metaclass'  => 'InsideOutClass::Instance'
  );

  __PACKAGE__->meta->add_attribute('foo' => (
      reader => 'get_foo',
      writer => 'set_foo'
  ));

  sub new  {
      my $class = shift;
      $class->meta->new_object(@_);
  }

  # now you can just use the class as normal

=head1 DESCRIPTION

This is a set of example metaclasses which implement the Inside-Out
class technique. What follows is a brief explaination of the code
found in this module.

We must create a subclass of B<Class::MOP::Instance> and override
the slot operations. This requires
overloading C<get_slot_value>, C<set_slot_value>, C<slot_initialized>, and
C<initialize_slot>, as well as their inline counterparts. Additionally we
overload C<add_slot> in order to initialize the global hash containing the
actual slot values.

And that is pretty much all. Of course I am ignoring need for
inside-out objects to be C<DESTROY>-ed, and some other details as
well (threading, etc), but this is an example. A real implementation is left as
an exercise to the reader.

=head1 AUTHORS

Stevan Little E<lt>stevan@iinteractive.comE<gt>

Yuval Kogman E<lt>nothingmuch@woobling.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright 2006-2008 by Infinity Interactive, Inc.

L<http://www.iinteractive.com>

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
